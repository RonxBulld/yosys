/*
 *  Generic Memory Template with Variable Port Count
 *  
 *  This file provides a flexible memory description that can be used as a 
 *  synthesis target for any memory configuration. The number of read and 
 *  write ports can be configured through parameters.
 *
 *  Author: Generated by AI Assistant
 *  License: Compatible with Yosys Open SYnthesis Suite
 */

// Generic Memory Module with Configurable Port Count
module generic_memory #(
    // Memory configuration parameters
    parameter MEMID = "generic_mem",
    parameter SIZE = 1024,              // Memory depth (number of words)
    parameter OFFSET = 0,               // Address offset
    parameter ABITS = 10,               // Address width (log2(SIZE))
    parameter WIDTH = 32,               // Data width per word
    parameter INIT = 0,                 // Initial memory content
    
    // Port configuration parameters
    parameter RD_PORTS = 2,             // Number of read ports
    parameter WR_PORTS = 2,             // Number of write ports
    
    // Read port configuration (bit vector for each port)
    parameter RD_CLK_ENABLE = {RD_PORTS{1'b1}},         // Clock enable per read port
    parameter RD_CLK_POLARITY = {RD_PORTS{1'b1}},       // Clock polarity per read port  
    parameter RD_TRANSPARENCY = {RD_PORTS{1'b0}},       // Transparency mode per read port
    parameter RD_COLLISION_X = {RD_PORTS{1'b0}},        // Collision behavior per read port
    parameter RD_CE_OVER_SRST = {RD_PORTS{1'b0}},       // Clock enable over sync reset
    parameter RD_ARST_VALUE = {RD_PORTS*WIDTH{1'b0}},   // Async reset value per read port
    parameter RD_SRST_VALUE = {RD_PORTS*WIDTH{1'b0}},   // Sync reset value per read port
    parameter RD_INIT_VALUE = {RD_PORTS*WIDTH{1'b0}},   // Initial value per read port
    
    // Write port configuration (bit vector for each port)
    parameter WR_CLK_ENABLE = {WR_PORTS{1'b1}},         // Clock enable per write port
    parameter WR_CLK_POLARITY = {WR_PORTS{1'b1}},       // Clock polarity per write port
    parameter WR_PRIORITY_MASK = {WR_PORTS*WR_PORTS{1'b0}}, // Write port priority mask
    parameter WR_WIDE_CONTINUATION = {WR_PORTS{1'b0}},  // Wide write continuation
    
    // Advanced configuration
    parameter OPTION_MODE = "GENERIC",  // Memory mode (can be customized)
    parameter OPTION_RESET = "SYNC",    // Reset type: "SYNC", "ASYNC", "NONE"
    parameter OPTION_WR_MODE = "NO_CHANGE" // Write mode: "NO_CHANGE", "READ_FIRST", "WRITE_FIRST"
) (
    // Read port interfaces
    input  [RD_PORTS-1:0] RD_CLK,                    // Read clocks
    input  [RD_PORTS-1:0] RD_EN,                     // Read enables
    input  [RD_PORTS-1:0] RD_ARST,                   // Async resets for read ports
    input  [RD_PORTS-1:0] RD_SRST,                   // Sync resets for read ports
    input  [RD_PORTS*ABITS-1:0] RD_ADDR,            // Read addresses
    output reg [RD_PORTS*WIDTH-1:0] RD_DATA,        // Read data outputs
    
    // Write port interfaces  
    input  [WR_PORTS-1:0] WR_CLK,                    // Write clocks
    input  [WR_PORTS-1:0] WR_EN,                     // Write enables (global per port)
    input  [WR_PORTS*WIDTH-1:0] WR_BE,              // Write byte enables (bit-level)
    input  [WR_PORTS*ABITS-1:0] WR_ADDR,            // Write addresses
    input  [WR_PORTS*WIDTH-1:0] WR_DATA             // Write data inputs
);

    // Memory array
    reg [WIDTH-1:0] memory [SIZE-1:0];
    
    // Internal state tracking
    integer i, j, k;
    reg [WR_PORTS-1:0] last_wr_clk;
    reg [RD_PORTS-1:0] last_rd_clk;
    
    // Helper function to detect clock edge
    function port_active;
        input clk_enable;
        input clk_polarity; 
        input last_clk;
        input this_clk;
        begin
            casez ({clk_enable, clk_polarity, last_clk, this_clk})
                4'b0???: port_active = 1;           // Combinational (always active)
                4'b1101: port_active = 1;           // Positive edge
                4'b1010: port_active = 1;           // Negative edge
                default: port_active = 0;           // No edge
            endcase
        end
    endfunction
    
    // Memory initialization
    initial begin
        for (i = 0; i < SIZE; i = i + 1) begin
            memory[i] = INIT >>> (i * WIDTH);
        end
        
        // Initialize read data outputs
        RD_DATA = RD_INIT_VALUE;
        
        // Initialize clock state tracking
        last_wr_clk = {WR_PORTS{1'b0}};
        last_rd_clk = {RD_PORTS{1'b0}};
    end
    
    // Main memory operation logic
    always @(*) begin
        // Handle asynchronous resets
        for (i = 0; i < RD_PORTS; i = i + 1) begin
            if (RD_ARST[i]) begin
                RD_DATA[i*WIDTH +: WIDTH] = RD_ARST_VALUE[i*WIDTH +: WIDTH];
            end
        end
    end
    
    always @(posedge RD_CLK or posedge RD_ARST or 
             posedge WR_CLK or negedge RD_CLK or negedge WR_CLK) begin
        
        // Write operations (highest priority)
        for (i = 0; i < WR_PORTS; i = i + 1) begin
            if (WR_EN[i] && port_active(WR_CLK_ENABLE[i], WR_CLK_POLARITY[i], 
                                       last_wr_clk[i], WR_CLK[i])) begin
                for (j = 0; j < WIDTH; j = j + 1) begin
                    if (WR_BE[i*WIDTH + j]) begin
                        memory[WR_ADDR[i*ABITS +: ABITS] - OFFSET][j] = WR_DATA[i*WIDTH + j];
                    end
                end
            end
        end
        
        // Read operations  
        for (i = 0; i < RD_PORTS; i = i + 1) begin
            if (RD_EN[i] && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i],
                                       last_rd_clk[i], RD_CLK[i])) begin
                
                // Handle synchronous reset
                if (RD_SRST[i] && (OPTION_RESET == "SYNC")) begin
                    RD_DATA[i*WIDTH +: WIDTH] <= RD_SRST_VALUE[i*WIDTH +: WIDTH];
                end 
                // Normal read operation
                else begin
                    RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];
                    
                    // Handle read-write transparency/collision
                    for (j = 0; j < WR_PORTS; j = j + 1) begin
                        if (RD_TRANSPARENCY[i] && WR_EN[j] && 
                            (RD_ADDR[i*ABITS +: ABITS] == WR_ADDR[j*ABITS +: ABITS]) &&
                            port_active(WR_CLK_ENABLE[j], WR_CLK_POLARITY[j], 
                                       last_wr_clk[j], WR_CLK[j])) begin
                            // Transparent write: read new data
                            for (k = 0; k < WIDTH; k = k + 1) begin
                                if (WR_BE[j*WIDTH + k]) begin
                                    RD_DATA[i*WIDTH + k] <= WR_DATA[j*WIDTH + k];
                                end
                            end
                        end
                        else if (RD_COLLISION_X[i] && WR_EN[j] &&
                                (RD_ADDR[i*ABITS +: ABITS] == WR_ADDR[j*ABITS +: ABITS])) begin
                            // Collision X mode: output unknown
                            RD_DATA[i*WIDTH +: WIDTH] <= {WIDTH{1'bx}};
                        end
                    end
                end
            end
        end
        
        // Update clock state tracking
        last_wr_clk <= WR_CLK;
        last_rd_clk <= RD_CLK;
    end
    
    // Optional: Debug and monitoring
    `ifdef DEBUG_MEMORY
    always @(posedge WR_CLK) begin
        for (i = 0; i < WR_PORTS; i = i + 1) begin
            if (WR_EN[i]) begin
                $display("[%0t] Memory %s: Write Port %0d: Addr=0x%0h, Data=0x%0h, BE=0x%0h", 
                        $time, MEMID, i, WR_ADDR[i*ABITS +: ABITS], 
                        WR_DATA[i*WIDTH +: WIDTH], WR_BE[i*WIDTH +: WIDTH]);
            end
        end
    end
    
    always @(posedge RD_CLK) begin
        for (i = 0; i < RD_PORTS; i = i + 1) begin
            if (RD_EN[i]) begin
                $display("[%0t] Memory %s: Read Port %0d: Addr=0x%0h, Data=0x%0h", 
                        $time, MEMID, i, RD_ADDR[i*ABITS +: ABITS], RD_DATA[i*WIDTH +: WIDTH]);
            end
        end
    end
    `endif

endmodule

// Example instantiation with different port configurations
// 
// Single-port memory (1R1W):
// generic_memory #(
//     .RD_PORTS(1), .WR_PORTS(1),
//     .SIZE(1024), .WIDTH(32), .ABITS(10)
// ) sp_mem (...);
//
// Dual-port memory (2R2W):  
// generic_memory #(
//     .RD_PORTS(2), .WR_PORTS(2),
//     .SIZE(2048), .WIDTH(64), .ABITS(11)
// ) dp_mem (...);
//
// Multi-port memory (4R2W):
// generic_memory #(
//     .RD_PORTS(4), .WR_PORTS(2), 
//     .SIZE(512), .WIDTH(16), .ABITS(9),
//     .RD_TRANSPARENCY(4'b1010)  // Transparent read on ports 1&3
// ) mp_mem (...);